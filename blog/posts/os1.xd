<style>
	p {
		white-space: pre-wrap;
	}
	img {
		width: 100%;
	}
</style>
# Notes on OS Construction: Booting (WIP)
#### September 30, 2019
#### Updated: October 2, 2019

	When a computer is turned on, special firmware that is stored in non-volalite memory is run. The two most popular kinds are BIOS and UEFI-based firmware. The original BIOS (Basic Input/Output System) firmware was created for the IBM PC in the 70s. Since there was no official spec, PCs since then have conformed to match its behavior.

	The BIOS's goal is to iterate through all of the attached media until it can successfully boot from one. At start-up, the CPU executes the BIOS program, and on x86 chips this will happen in 16-bit mode. During boot, the BIOS loads the first block from disk, called the Master Boot Record (MBR), which contains bootstrapping code, a partition table, and the disk signature. The MBR is 512 bytes and is loaded into the physical address 0x7C00. Why? [Apparently](0x7C00), this was a conscious decision by the IBM PC 5150 development team to leave surrounding memory available for interrupt vectors, the BIOS, and the OS. The BIOS checks that the signature matches 0xAA55 and proceeds to execute the boostrapping code.

### "Hello, World!"

	I put together a simple BIOS-based boot program that prints "Hello, World!" to the screen. The source can be found on the [boot-bios-helloworld](boot-bios-helloworld) branch of my [oscons](oscons) GitHub repository. I use [YASM](YASM) to assemble the source into a flat binary named `boot.img`,
```
$ yasm -f bin boot.asm -o boot.img
```
    and [QEMU](QEMU) to emulate either an i386 or x86_64 machine with this image loaded onto its disk.
```
$ qemu-system-<i386|x86_64> -drive format=raw,file=boot.img
```
    We first issue some directives to tell YASM that we are assembling 16-bit instructions that should be loaded at the address 0x7C00.
```
bits         16
org          0x7C00
```
    The BIOS interrupt vector 0x10 contains handlers that perform video services. For this program, we want to write to the Teletype, so we specify 0x0E as the handler in the ah register. This handler takes in the character to write in the al register, so we can make use of the [LODSB](LODSB) instruction to iterate through the characters stored at `HELLO_STRING`, which expects the offset from the segment to be stored in the si register.
```
mov          si, HELLO_STRING
mov          ah, 0x0E
```
    Now we just loop over the `NULL`-terminated string and print each character by calling the interrupt. Once we've reached the end of the strings, terminate the program.
```
.loop:
    lodsb
    cmp          al, 0
    je           end
    int          0x10
    jmp          .loop

end:
    hlt
```
    Make sure to declare the string constant in memory, and set the last two bytes in the block to 0xAA55, zeroing out the bytes in between.
```
HELLO_STRING: db "Hello, World!", 0
    times 510 - ($-$$) db 0
    dw           0xAA55
```
    Executing this bootloader program should result in output like this:

<img src="/static/bios-boot-helloworld.png" alt='A window running QEMU that displays "Hello, World!"'></img>

### Protected Mode

    Bootloaders will often run in multiple stages, to access more program memory. The bootstrapping code in the MBR will usually load another block corresponding to the Volume Boot Record (VBR), which is located in a separate partition that is found by scanning the MBR's partition table. Eventually the loader will want to enter protected mode, with access to a larger address space and 32-bit registers.

    This process involves setting up the Global Descriptor Table (GDT), setting up the Interrupt Descriptor Table (IDT), and enabling the A20 Line. Real mode uses segmented addressing, where two segment registers can store a logical address composed of a 16-bit base and 16-bit offset. Its 20-bit physical address is computed as `(base<<4) + offset`. Protected mode uses descriptors to translate logical addresses to physical addresses.

    The GDT contains 8-byte entries, each of which has a base address, segment length, and other configurable attributes like access permissions. Indexes into the GDT are called selectors. Every GDT is required to have its first descriptor be **`NULL`**. By initializing unused segments with this entry, an exception is triggered when unused segments are referenced. The GDT can be loaded with the `LGDT` instruction.

    Interrupts are a way to notify the CPU about an event, and have it execute some code. In real mode, a table of interrupt handlers is loaded and reserved between the physical addresses 0x0000 and 0x03FF, where each pointer is 4 bytes. These range from division-by-zero to [BIOS interrupts](INTBIOS) that can write to the screen. Entering protected mode will require disabling interrupts beforehand. In protected mode, there is no predefined table, and BIOS interrupts are no longer accessible.

    An IDT needs to be set up, which is also an array of descriptors, each of which has a selector into the GDT for the code segment where the interrupt handler is located, an offset to the specific interrupt handler, and configurable attributes like its privilege level and gate type. Gate types include the task gate (to indicate a task switch and save context), trap gate (to call an interrupt handler), and interrupt gate (to disable interrupts when the handler is executed). The IDT can be loaded with the `LIDT` instruction.

**TODO:** *Figures for Segment Descriptor Layouts*

    In order to address up to 4GB of memory, the 21st (indexed from zero) address line must be explicitly be enabled. Why isn't this enabled by default? Before processors with more than 20 address lines were introduced, accessing an address past 1MB would wrap around. Some engineers depended on this behavior, so in an effort to stay backwards compatible, the 21st address line (A20 line) is disabled by default. There are many ways of turning on the A20 line, all of which are required to have the widest processor support. 

    Finally, set the Protection Enable (PE) bit in CR0, a control register. Perform a jump to a far address to clear the prefetch queue, and initialize protected mode. This will involve initializing the segment registers with a data segment from the GDT, re-enabling interrupts, and jumping to the kernel.

    **NOTE:** *There is an additional process when entering long mode, a.k.a 64-bit mode, which involves CPU feature detection, disabling and re-enabling interrupts, setting up paging, setting the long mode bit in the model-specific-register, and updating the GDT and IDT.*

**TODO:** *Describe the UEFI Boot Process*

[0x7C00]: https://www.glamenv-septzen.net/en/view/6
[boot-bios-helloworld]: https://github.com/smasher164/oscons/tree/boot-bios-helloworld
[oscons]: https://github.com/smasher164/oscons
[YASM]: https://yasm.tortall.net/
[QEMU]: https://www.qemu.org/
[LODSB]: http://faydoc.tripod.com/cpu/lodsb.htm
[INTBIOS]: https://en.wikipedia.org/wiki/BIOS_interrupt_call